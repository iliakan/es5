<!DOCTYPE html>
<html class="split chapter"><head>

<meta charset="utf-8"><title>5 Соглашения о наименованиях | ES5 на русском</title><link rel="stylesheet" href="style.css"><link href="x4.html" title="4 Общий обзор " rel="prev">
  <link href="index.html" title="Содержание" rel="index">
  <link href="x6.html" title="6 Исходный текст " rel="next">
  </head><body><div class="head">
<h2 id="top">Спецификация ECMAScript 5.1 с аннотациями <span id="timestamp"></span></h2>
<!--left..-->

<div id="slogan">
  <div class="share">
  <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://es5.javascript.ru/" data-lang="ru" data-size="large" data-count="horizontal">Твитнуть</a>
  <div id="fb-root"></div>
  <div style="margin-bottom:5px" class="fb-like" data-href="http://es5.javascript.ru/" data-send="false" data-action="recommend" data-layout="button_count" data-width="300" data-show-faces="false" data-font="arial"></div>
  <div class="vk-share-wrapper">
  <script src="http://vkontakte.ru/js/api/share.js?9" charset="windows-1251"></script>  
  <script src="misc.js"></script>
  </div>

  <div style="margin-top:6px">
  <g:plusone annotation="inline" href="http://es5.javascript.ru/" width="120" size="standard" style="vertical-align:middle"></g:plusone>
  </div>
  </div>
</div>
<!--..left-->

<div id="annotations">



</div>
</div>
<nav>
   <a href="x4.html">&#8592; 4 Общий обзор </a> &#8211;
   <a href="index.html" class="toc-nav">Содержание</a> &#8211;
   <a href="x6.html">6 Исходный текст &#8594;</a>
  <ol class="toc"><li><a href="x5.html#x5" id="x5-toc">5 Соглашения о наименованиях</a>
    <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x5.html#x5.1" id="x5.1-toc">5.1 Синтаксическая и лексическая грамматики</a>
        <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x5.html#x5.1.1" id="x5.1.1-toc">5.1.1 Контекстно-свободные грамматики</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x5.html#x5.1.2" id="x5.1.2-toc">5.1.2 Лексическая грамматика и грамматика регулярных выражений</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x5.html#x5.1.3" id="x5.1.3-toc">5.1.3 Строково-числовая грамматика</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x5.html#x5.1.4" id="x5.1.4-toc">5.1.4 Синтаксическая грамматика</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x5.html#x5.1.5" id="x5.1.5-toc">5.1.5 Грамматика JSON</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x5.html#x5.1.6" id="x5.1.6-toc">5.1.6 Грамматическая нотация</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x5.html#x5.2" id="x5.2-toc">5.2 Соглашения об алгоритмах</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li></ol></nav>

  <h2 id="x5">5 Соглашения о наименованиях <a href="#x5">#</a> <a href="#x5-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h2>
	<h3 id="x5.1">5.1 Синтаксическая и лексическая грамматики <a href="#x5.1">#</a> <a href="#x5.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h3>
	<h4 id="x5.1.1">5.1.1 Контекстно-свободные грамматики <a href="#x5.1.1">#</a> <a href="#x5.1.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>

	<p>
	<i>Контекстно-свободная грамматика</i> состоит из ряда <i>порождающих правил</i> <em>productions</em>. <i>В левой части </i>каждого правила имеется абстрактный символ &ndash; <I>нетерминал</I>, а <I>в правой части</I> &ndash; последовательность нетерминальных и <I>терминальных </I>символов в количестве ноль или более. Для каждой грамматики терминальные символы берутся из определенного предписанного алфавита.</p>
	<p>
	Начиная с предложения, состоящего из одиночного помеченного нетерминала &ndash; <i>начального символа,</i> данная КС грамматика определяет <i>язык</i>, а именно &ndash; ряд (возможно, бесконечный) допустимых последовательностей терминальных символов, которые могут получиться в результате неоднократной замены какого-либо нетерминала в этой последовательности на символы, указанные в правой стороне правила, для которого этот нетерминал является левой частью.</p>
	<h4 id="x5.1.2">5.1.2 Лексическая грамматика и грамматика регулярных выражений <a href="#x5.1.2">#</a> <a href="#x5.1.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	<i>Лексическая грамматика</i> для ECMAScript приведена в <a href="x7.html#x7">Главе 7</a>. В качестве терминальных символов в этой грамматике используются символы Юникода, подчиняющиеся правилам для символа <I>SourceCharacter </I> <tt>Исходный символ</tt>, изложенным в <a href="x6.html#x6">Главе 6</a>. Эта грамматика определяет набор правил, начиная с начального символа <I>InputElementDiv </I><tt>Входной элемент деления</tt> или <I>InputElementRegExp </I><tt>Входной элемент регулярного выражения</tt>, описывающих преобразование последовательностей указанных символов в последовательность входных элементов.</p>
	<p>
	В синтаксической грамматике для ECMAScript терминальными символами являются входные элементы, отличные от пробельных символов и комментариев. Они называются <I>токенами </I>ECMAScript. К ним относятся зарезервированные (ключевые) слова, идентификаторы, литералы и знаки пунктуации языка ECMAScript. Кроме того, символы окончания строки, хоть и не считаются токенами, также становятся частью потока входных элементов и руководят процессом автоматической вставки точки с запятой (См. <a href="x7.html#x7.9">пункт 7.9</a>). Простые пробелы и однострочные комментарии игнорируются и не появляются в потоке входных элементов синтаксической грамматики. Символ <I>MultiLineComment </I><tt>Многострочный комментерий</tt> &ndash; то есть, комментарий в виде &ldquo;<code>/*</code>…<code>*/</code>&rdquo;, независимо от того, занимает ли он одну или несколько строк &ndash; также просто игнорируется, если не содержит символа окончания строки. Если же он содержит один или несколько символов окончания строки, он заменяется единичным символом окончания строки, который становится частью потока входных элементов синтаксической грамматики.</p>
	<p>
	<I>Грамматика регулярных выражений</I> (от английского <i>RegExp grammar</i>, то есть &quot;Regular Expressions grammar&quot; &ndash; прим. перев.) для ECMAScript приведена в <a href="x15.10.html#x15.10">Главе 15.10</a>. Символы, которые используются в этой грамматике в качестве терминальных, также подчиняются правилам для символа <i>SourceCharacter</i>. Она определяет набор правил, начиная с начального символа <i><I><I>Pattern</I></I></i> <tt>Шаблон</tt>, описывающих преобразование последовательностей символов в шаблоны регулярных выражений.</p>
	<p>
	В качестве разделительного знака в правилах лексической грамматики и грамматики регулярных выражений используется двойное двоеточие&nbsp;&ldquo;<b>::</b>&rdquo;. Некоторые правила являются общими для этих грамматик.</p>
	<h4 id="x5.1.3">5.1.3 Строково-числовая (Numeric String) грамматика <a href="#x5.1.3">#</a> <a href="#x5.1.3-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	Еще одна грамматика используется для преобразования строки в числовое значение. Она схожа с лексической грамматикой в той части, которая касается числовых литералов. В качестве терминального символа используется. Описание этой грамматики приводится в <a href="x9.html#x9.3.1">пункте&nbsp;9.3.1</a>.</p>
	<p>
	В качестве разделительного знака строково-числовой грамматики используется тройное двоеточие&nbsp;&ldquo;<b>:::</b>&rdquo;.</p>
	<h4 id="x5.1.4">5.1.4 Синтаксическая грамматика <a href="#x5.1.4">#</a> <a href="#x5.1.4-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	<i>Синтаксическая грамматика </i>для ECMAScript описана в разделах 11, 12, 13 и 14. Терминальными символами в данной грамматике являются токены ECMAScript, определенные в лексической грамматике (<a href="#x5.1.2">см. пункт 5.1.2</a>). Синтаксическая грамматика определяет набор правил, начиная с начального символа <a href="x14.html#x14"><I><I>Program</I></I></a> <tt>Программа</tt>, описывающих, как последовательности токенов могут образовывать синтаксически корректные программы на ECMAScript.</p>
	<p>
	При распознавании потока символов в качестве программы на ECMAScript сначала этот поток преобразуется в поток входных элементов посредством неоднократного применения лексической грамматики, а затем производится распознавание этого потока входных элементов посредством однократного применения синтаксической грамматики. Считается, что программа имеет синтаксическую ошибку, если токены в этом потоке входных элементов не могут быть распознаны как единичный экземпляр начального нетерминала <i><a href="x14.html#x14">Program</a></i> так, чтобы при этом не оставалось лишних токенов.</p>
	<p>
	В качестве разделительного знака в правилах синтаксической грамматики используется одиночное двоеточие&nbsp;&ldquo;<b>:</b>&rdquo;.</p>
	<p>
	Вообще-то, описание синтаксической грамматики, приведенное в пунктах 11, 12, 13 и 14, не полностью определяет, какие последовательности токенов являются допустимыми в качестве корректных программ на ECMAScript. Допускаются также еще некоторые дополнительные последовательности токенов, а именно &ndash; те, которые бы описывала эта грамматика, если бы к этим последовательностям добавлялись синтаксические знаки &quot;точка с запятой&quot; в определенных местах &ndash; например, перед символами окончания строки. Кроме того, некоторые описываемые последовательности токенов считаются недопустимыми, если символ окончания строки встречается в определенных &quot;неудобных&quot; местах.</p>
	<h4 id="x5.1.5">5.1.5 Грамматика JSON <a href="#x5.1.5">#</a> <a href="#x5.1.5-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	Грамматика JSON используется для преобразования строки, описывающей набор объектов ECMAScript, в фактические объекты. Грамматика JSON приведена в <a href="x15.12.html#x15.12.1">пункте&nbsp;15.12.1</a>.</p>
	<p>
	Грамматика JSON состоит из лексической грамматики JSON и синтаксической грамматики JSON. Лексическая грамматика JSON используется для преобразования последовательностей символов в токены. В некоторых частях она аналогична лексической грамматике ECMAScript. Синтаксическая грамматика JSON определяет способ преобразования последовательностей токенов из лексической грамматики JSON в синтаксически правильные описания объекта JSON.</p>
	<p>
	В качестве разделительного знака в правилах лексической грамматики JSON используется двойное двоеточие &ldquo;<b>::</b>&rdquo;. В лексической грамматике JSON используются некоторые правила из лексической грамматики ECMAScript. В некоторых частях синтаксическая грамматика JSON аналогична синтаксической грамматике ECMAScript.  В качестве разделительного знака в правилах синтаксической грамматики JSON используется одиночное двоеточие &ldquo;<b>:</b>&rdquo;.</p>
	<h4 id="x5.1.6">5.1.6 Грамматическая нотация <a href="#x5.1.6">#</a> <a href="#x5.1.6-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	Терминальные символы лексической и строковой грамматики, а также некоторые терминальные символы синтаксической грамматики обозначаются <code><b>моноширинным</b></code> шрифтом и в правилах грамматики, и в тексте данной спецификации, если речь идет непосредственно о таком терминальном символе. В программе эти символы должны быть указаны в точности так, как они пишутся. Все терминальные символы, обозначенные таким образом, должны пониматься как соответствующие юникодные ASCII-символы, и не должны толковаться как другие символы Юникода, аналогичные по написанию.</p>
	<p>
	Для обозначения нетерминальных символов используется <i>курсив</i>. При определении нетерминала сначала указывается имя определяемого нетерминала, после которого следует одно или несколько двоеточий &ndash; в зависимости от типа грамматики, к которой относится данное правило. Затем на следующих строках содержится один или несколько вариантов правой части правила для этого нетерминала. Например, в приведенном ниже синтаксическом определении</p>
	<p class="def1">
	<i>WhileStatement </i><b>:</b></p>
	<p class="def2">
	<code><b>while</b></code> <code><b>(</b></code> <i>Выражение </i><code><b>)</b></code> <i>Инструкция</i></p>
	<p>
	указано, что нетерминал <I>WhileStatement</I> <tt>Инструкция&nbsp;While</tt> представляет токен <code><b>while</b></code>, за которым следует токен открывающейся скобки, затем <i>Expression</i> <tt>Выражение</tt>, а затем токен закрывающейся скобки, за которым следует <I>Statement</I> <tt>Инструкция</tt>. Экземпляры <i>Expression</i> и <i>Statement</i> сами являются нетерминалами. Приведем еще один пример синтаксического определения:</p>
	<p class="def1">
	<i>ArgumentList</i><b>:</b></p>
	<p class="def2">
	<i>AssignmentExpression<br>ArgumentList</i><code><b>,</b></code> <i>AssignmentExpression</i></p>
	<p>
	в котором утверждается, что <i>ArgumentList</i> <tt>Список аргументов</tt> может представлять либо единичное <i>AssignmentExpression</i> <tt>Выражение присваивания</tt>, либо <I>ArgumentList</I>, за которым следует запятая, а за ней &ndash; <i>AssignmentExpression</i>. Данное определение нетерминала <i>ArgumentList</i> является рекурсивным, то есть &ndash; на основе самого себя. В результате <i>ArgumentList</i> может содержать любое положительное число аргументов, разделенных запятыми, где каждое выражение аргумента представляет собой <i>AssignmentExpression</i>. Такие рекурсивные определения нетерминалов используются достаточно часто.</p>
	<p>
	Если после терминального или нетерминального символа стоит подстрочный суффикс &ldquo;<sub>opt</sub>&rdquo; (от английского &quot;optional&quot; &ndash; прим. перев.), он означает, что этот символ является необязательным. Вариант, содержащий необязательный символ, в действительности определяет две правые части: одну с этим обязательным элементом и одну &ndash; без него. Это означает, что</p>
	<p class="def1">
	<i>VariableDeclaration</i><b>:</b></p>
	<p class="def2">
	<i>Identifier Initialiser</i><sub>opt</sub></p>
	<p>
	является удобной сокращенной формой следующего представления:</p>
	<p class="def1">
	<i>VariableDeclaration</i><b>:</b></p>
	<p class="def2">
	<i>Identifier<br>Identifier Initialiser</i></p>
	<p>
	а также, что</p>
	<p class="def1">
	<i>IterationStatement</i><b>:</b></p>
	<p class="def2">
	<code><b>for (</b></code> <i>ExpressionNoIn</i><sub>opt</sub><code><b>;</b></code> <i>Expression</i><sub>opt</sub><code><b>;</b></code> <i>Expression</i><sub>opt</sub><code><b>)</b></code> <i>Statement</i></p>
	<p>
	является удобной сокращенной формой для следующей записи:</p>
	<p class="def1">
	<i>ИнструкцияИтерации</i><b>:</b></p>
	<p class="def2">
	<code><b>for ( ;</b></code> <i>Expression</i><sub>opt</sub><code><b>;</b></code> <i>Expression</i><sub>opt</sub><code><b>)</b></code> <i>Statement</i><code><b><br>for (</b></code> <i>ExpressionNoIn</i><code><b>;</b></code> <i>Expression</i><sub>opt</sub><code><b>;</b></code> <i>Expression</i><sub>opt</sub><code><b>)</b></code> <i>Statement</i></p>
	<p>
	которая, в свою очередь, является сокращением для следующей записи:</p>
	<p class="def1">
	<i>IterationStatement</i><b>:</b></p>
	<p class="def2">
	<code><b>for ( ; ;</b></code> <i>Expression</i><sub>opt</sub><code><b>)</b></code> <i>Statement</i><code><b><br>for ( ;</b></code> <i>Expression</i><code><b>;</b></code> <i>Expression</i><sub>opt</sub><code><b>)</b></code> <i>Statement</i><code><b><br>for (</b></code> <i>ExpressionNoIn</i><code><b>; ;</b></code> <i>Expression</i><sub>opt</sub><code><b>)</b></code> <i>Statement</i><code><b><br>for (</b></code> <i>ExpressionNoIn</i><code><b>;</b></code> <i>Expression</i><code><b>;</b></code> <i>Expression</i><sub>opt</sub><code><b>)</b></code> <i>Statement</i></p>
	<p>
	которая, в свою очередь, является сокращением для следующего:</p>
	<p class="def1">
	<i>IterationStatement</i><b>:</b></p>
	<p class="def2">
	<code><b>for ( ; ; )</b></code> <i>Statement<br></i><code><b>for ( ; ;</b></code> <i>Expression</i><code><b>)</b></code> <i>Statement</i><code><b><br>for ( ;</b></code> <i>Expression</i><code><b>; )</b></code> <i>Statement</i><code><b><br>for ( ;</b></code> <i>Expression</i><code><b>;</b></code> <i>Expression</i><code><b>)</b></code> <i>Statement</i><code><b><br>for (</b></code> <i>ExpressionNoIn </i><code><b>; ; )</b></code> <i>Statement</i><code><b><br>for (</b></code> <i>ExpressionNoIn </i><code><b>; ;</b></code> <i>Expression</i><code><b>)</b></code> <i>Statement</i><code><b><br>for (</b></code> <i>ExpressionNoIn </i><code><b>;</b></code> <i>Expression</i><code><b>; )</b></code> <i>Statement</i><code><b><br>for (</b></code> <i>ExpressionNoIn </i><code><b>;</b></code> <i>Expression</i><code><b>;</b></code> <i>Expression</i><code><b>)</b></code> <i>Statement</i></p>
	<p>
	и, таким образом, нетерминал <I>ИнструкцияИтерации </I>в действительности имеет восемь вариантов правой части.</p>
	<p>
	Если в правой части правила содержится фраза &quot;[empty]&quot; <tt>[пусто]</tt>, это означает, что в правой части правила отсутствуют терминалы или нетерминалы.</p>
	<p>
	Если в правой части правила содержится фраза <dfn id="lookahead-not-in">&ldquo;[lookahead <span class="symbol">&#8713;</span> <i>set</i>], <tt>[предпросмотр <span class="symbol">&#8713;</span> <i>множество</i>]</tt>, это означает, что данное правило не может быть использовано, если непосредственно следующий за ним входной токен является элементом этого <I>set</I>. Этот <I>set </I>может быть описан в виде списка терминалов, взятого в фигурные скобки. В целях удобства это множества также может быть описано в виде нетерминала, и в этом случае оно представляет собой множество всех терминалов, на которые можно разложить этот нетерминал. Например, с учетом следующих определений</dfn></p>
	<p class="def1">
	<i>DecimalDigit </i><b>::</b><b>one of</b></p>
	<p class="def2-alt">
	<code><b>0 1  2  3  4  5  6  7  8  9</b></code></p>
	<p class="def1">
	<i>DecimalDigits</i><b>::</b></p>
	<p class="def2">
	<i>DecimalDigit<br>DecimalDigits DecimalDigit</i></p>
	<p>
	определение</p>
	<p class="def1">
	<i>LookaheadExample</i><b>::</b></p>
	<p class="def2">
	<code><b>n</b></code> [<a href="#lookahead-not-in">lookahead <span class="symbol">&#8713;</span></a> {<code><b>1</b></code> <i>, </i><code><b>3</b></code> <i>, </i><code><b>5</b></code> <i>, </i><code><b>7</b></code> <i>, </i><code><b>9</b></code>}]<i>DecimalDigits<br>DecimalDigit  </i>[<a href="#lookahead-not-in">lookahead <span class="symbol">&#8713;</span></a> <i>DecimalDigit </i>]</p>
	<p>
	соответствует либо букве&nbsp;<code><b>n</b></code>, после которой следует одна или несколько десятичных цифр, первая из которых является четной, либо соответствует десятичной цифре, после которой не следует какой-либо другой десятичной цифры.</p>
	<p>
	<dfn id="restricted-production">Если в правой части правила синтаксической грамматики содержится фраза &ldquo;[no <i>LineTerminator</i> here]&rdquo; <tt>[здесь <i>Конец строки</i> отсутствует]</tt>, это указывает на то, что данное правило является  <I>ограниченным порождением</I>, или <I>ограниченным правилом</I></dfn> (англ. &quot;<i>restricted production</i>&quot; &ndash; прим. перев.): оно не может быть использовано, если во входном потоке в указанной позиции встречается <I>LineTerminator </I><tt>Конец строки</tt><i>.</i> Например, приведенное ниже правило</p>
	<p class="def1">
	<i>ReturnStatement</i><b>:</b></p>
	<p class="def2">
	<code><b>return</b></code><a href="#restricted-production">[no <i>LineTerminator</i> here]</a><code></code> <i>Expression</i><sub>opt</sub><code><b>;</b></code></p>
	<p>
	указывает на то, что данное правило не может быть использовано, если в программе между токеном <code><b>return</b></code> и <I>Expression </I>стоит <I>LineTerminator</I>.</p>
	<p>
	Если ограниченное правило не запрещает присутствие символа <i>LineTerminator</i> то между двумя последовательными токенами в потоке входных элементов может находиться любое количество символов <I>LineTerminator</I>, не затрагивая синтаксической корректности этой программы.</p>
	<p>
	Если после единичного или многократного двоеточия в грамматическом определении следует фраза &ldquo;<b>one of</b>&rdquo; <tt>один из</tt> это значит, что каждый из терминальных символов, расположенных на следующей строке или строках, является одним из вариантов определения. Например, лексическая грамматика ECMAScript содержит следующее правило:</p>
	<p class="def1">
	<i>NonZeroDigit </i><b>::</b><b>one of</b></p>
	<p class="def2-alt">
	<code><b>1 2  3  4  5  6  7  8  9</b></code></p>
	<p>
	что, по сути, является удобной сокращенной формой для следующей записи:</p>
	<p class="def1">
	<i>NonZeroDigit </i><b>::</b></p>
	<p class="def2-alt">
	<code><b>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</b></code></p>
	<p>
	Если альтернативный вариант в правиле лексической грамматики или строково-числовой грамматики является многознаковым токеном, он представляет собой последовательность символов, которые могли бы образовать такой токен.</p>
	<p>
	Правая сторона правила может содержать указание на то, что некоторые варианты развертывания недопустимы. Для этого используется фраза &ldquo;<b>but not</b>&rdquo; <tt>но не</tt>, а после нее &ndash; развертывания, которые следует исключить. Например, приведенное ниже правило</p>
	<p class="def1">
	<i>Identifier</i><b>::</b></p>
	<p class="def2">
	<i>IdentifierName </i><b>but not</b><i> ReservedWord</i></p>
	<p>
	означает, что нетерминал <i>Identifier </i><tt>Идентификатор</tt> может быть заменен любой последовательностью символов, которые могут заменить <I>IdentifierName </I><tt>Имя идентификатора</tt>, при условии, что эта последовательность символов не может заменить <I>ReservedWord</I> <tt>Зарезервированное слово</tt>.</p>
	<p>
	И, наконец, если перечислить все возможные варианты нереально, некоторые нетерминальные символы передаются описательными фразами, изложенными рубленым шрифтом: </p>
	<p class="def1">
	<i>SourceCharacter</i> <b>::</b></p>
	<p class="def2-alt">
	любой символ Юникода</p>
	<h3 id="x5.2">5.2 Соглашения об алгоритмах <a href="#x5.2">#</a> <a href="#x5.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h3>
	<p>
	В данной спецификации для обозначения шагов алгоритма часто используются нумерованные списки. Эти алгоритмы используются для точного указания обязательной семантики языковых конструкций ECMAScript. Данные алгоритмы не подразумевают использование какой-либо определенной техники реализации. На деле, вполне возможно наличие более эффективных алгоритмов для реализации тех или иных функциональных возможностей.</p>
	<p>
	Некоторые алгоритмы, которые называются <I>абстрактные операции</I>, именуются и записываются в параметризованной функциональной форме так, чтобы на них можно было легко ссылаться по имени из любого другого алгоритма. Это предусмотрено для того, чтобы сделать более удобным использование этих алгоритмов в различных частях данной спецификации.</p>
	<p>
	Если в результате выполнения алгоритма должно получиться значение, используется директива &ldquo;return <i>x</i>&rdquo;, <tt>вернуть <i>x</i></tt>, указывающая на то, что результатом этого алгоритма является значение <i>x</i>, и что выполнение этого алгоритма должно прекратиться. Запись &quot;Result(<i>n</i>)&quot; <tt>Результат(<i>n</i>)</tt> является сокращенным вариантом фразы &ldquo;результат шага <i>n</i>&rdquo;.
	
	</p>
	<p>
	Для более понятного изложения шаги алгоритма могут быть поделены на дальнейшие подшаги. Подшаги, в свою очередь, тоже могут подразделяться на следующие подшаги, оформленные с отступом.  Для обозначения подшагов используются правила нумерации: для нумерации подшагов  первого уровня используют знаки алфавита в нижнем регистре, а для нумерации подшагов второго уровня используют римские цифры в нижнем регистре. Если для отображения алгоритма требуется более трех уровней, эти правила нумерации повторяются, начиная с цифрового обозначения на четвертом уровне.  Например:</p>
	<ol><li><p>
		Шаг верхнего уровня</p>
		<ol><li><p>
			Подшаг</p>
			</li>
			<li><p>
			Подшаг
			
			</p>
			<ol><li><p>
				Подподшаг</p>
				</li>
				<li><p>
				Подподшаг</p>
				<ol><li><p>
					Подподподшаг</p>
					<ol><li><p>
						Подподподподшаг</p>
					</li></ol></li></ol></li></ol></li></ol></li></ol><p>
	Шаг или подшаг может быть записан как предикат&nbsp;&quot;if&quot; <tt>если</tt>, определяющий свои подшаги,  тогда переход на уровень подшагов будет возможен только в том случае, если условие в предикате является истинным. Шаг, или подшаг, начинающийся со слова &quot;else&quot; <tt>иначе</tt>, является предикатом, отрицающим предшествующий шаг-предикат &quot;if&quot; того же уровня.</p>
	<p>
	Шаг может задавать итеративное применение своих подшагов.</p>
	<p>
	Математические операции, такие как сложение, вычитание, отрицание, умножение, деление, а также математические функции, определение которым будет дано далее в этом пункте, следует всегда понимать как получение точных математических результатов вычислений, производимых с действительными математическими числами, к которым не относятся бесконечности и отрицательный ноль (отличный от положительного нуля). Алгоритмы в данном стандарте, по которым строятся арифметические действия с плавающей запятой, в случае необходимости включают явные шаги для работы с бесконечностями, с нулем со знаком, а также для выполнения округления. Если к числу с плавающей запятой применяется математическая операция или функция, следует понимать, что эта операция или функция применяются к точному математическому значению, представленному этим числом с плавающей запятой. При этом такое число должно быть конечным; если это  <b>+0</b> или <span class="symbol"><b>&#8722;</b></span><b>0</b>, то соответствующее математическое значение принимается как просто <b>0</b>.</p>
	<p>
	Математическая функция <dfn id="abs">abs(<i>x</i>)</dfn> возвращает абсолютное значение (модуль) <i>x</i>, которое равно <span class="symbol">&#8722;</span><i>x</i>, если <i>x</i> отрицателен (меньше нуля); в противном случае оно равно собственно <i>x</i>.</p>
	<p>
	Математическая функция <dfn id="sign">sign</dfn>(<i>x</i>) возвращает 1 , если <i>x</i> положительный, и <span class="symbol">&#8722;</span>1, если <i>x</i> отрицательный. В данном стандарте знаковая функция не используется в тех случаях, если <i>x</i> равен нулю.</p>
	<p>
	Запись <dfn id="modulo">&ldquo;<i>x</i> modulo <i>y</i>&rdquo; (<i>y</i> должен быть конечным и отличным от нуля) вычисляет значение&nbsp;<i>k</i> с таким же знаком, что и <i>y</i> (или ноль) так, чтобы <a href="#abs">abs</a>(<i>k</i>) &lt; <a href="#abs">abs</a>(<i>y</i>) и <i>x</i><span class="symbol">&#8722;</span><i>k </i>= <i>q</i> <span class="symbol">&#215;</span> <i>y</i> для некоторого целого <i>q</i>.</dfn></p>
	<p>
	Математическая функция <dfn id="floor">floor</dfn>(<i>x</i>) возвращает наибольшее целое (ближайшее к положительной бесконечности), не превышающее&nbsp;<i>x</i>.</p>
	<p><b>ПРИМЕЧАНИЕ</b> floor(<i>x</i>) = <i>x</i><span class="symbol">&#8722;</span>(<i>x</i> modulo 1).</p>
	<p class="sp">
	Если по определению алгоритм должен &quot;сгенерировать исключение&quot;, выполнение алгоритма прекращается, при этом результат не возвращается.  Кроме того, прекращается выполнение вызвавших его алгоритмов до момента достижения того шага, который явно обрабатывает это исключение, используя терминологию типа &quot;Если было сгенерировано исключение...&quot; Сразу же по достижении такого шага алгоритма считается, что исключение не имело места.</p>
	</body><script src="anno.js"></script></html>